#' A wrapper around '\%dopar\%' to recover messages/warnings in GUI environments
#' 
#' A fifo connection is opened and all output from the forked processes is
#' written to a temp file. After all processes finish, the file is read, deleted
#' and its contents returned together with the result of the actual parallel
#' computation.
#'
#' @param obj  A foreach object like for regular \%dopar\% (see foreach package
#'             documentation)
#' @param expr An expression to be evaluated in parallel like for regular
#'             \%dopar\% (see foreach package documentation)
#'
#' @return A list with slots res for the actual result of the parallel
#'         computation and out for the output generated by the individual
#'         processes
#'
#' @examples
#' test <- function() {
#'   message("abc")
#'   warning("def")
#'   1:5 + 1:3
#' }
#' 
#' library(singleCellFeatures)
#' 
#' registerDoMC(cores=detectCores())
#' res <- foreach(1:10, .combine=rbind) %doparMC% test()
#' 
#' message(paste(res$out, collapse="\n"))
#' res$res
#' 
#' @export
"%doparMC%" <- function(obj, expr) {
  filename <- tempfile()
  con <- fifo(filename, "w+")
  assign(x="con", value=con, envir=.GlobalEnv)

  e <- foreach:::getDoPar()
  result <- e$fun(
    obj,
    substitute({
      warnLevel <- getOption("warn")
      options(warn=1)
      sink(file=con, append=TRUE, type="message")
      on.exit({
        sink(file=NULL, type="message")
        options(warn=warnLevel)
      })
      res <- eval(expr)
    }),
    parent.frame(), e$data
  )

  output <- readLines(con)
  on.exit({
    unlink(filename)
    close(con)
    rm(con, envir=.GlobalEnv)
  })
  return(list(res=result, out=output))
}

#' A wrapper around saveRDS to enable multicore compression
#' 
#' Piping the datastream to be saved through pigz enables the use of multiple
#' cores for compression.
#'
#' @param object  An object to be saved
#' @param file    The filename of the resulting .rds file
#' @param threads the number of threads to be used for compression (default:
#'                all-1)
#'
#' @return NULL (invisibly). The object is saved to the filesystem.
#'
#' @examples
#' obj <- list(a=1, b=2)
#' saveRDSMC(obj, "~/obj.rds")
#' 
#' @export
saveRDSMC <- function(object, file, threads=detectCores() - 1) {
  message("using ", threads, " threads for compression.")
  #con <- pipe(paste0("xz -T", threads, " -9 -f > ", file), "wb")
  con <- pipe(paste0("pigz -p ", threads, " -9 -f > ", file), "wb")
  saveRDS(object, file = con)
  on.exit(if(exists("con")) close(con))
}

#' A wrapper around readRDS for faster reading of compressed files
#' 
#' Although decompressing files with pigz is not parallelized, it is faster to
#' run the decompression in a separate process.
#'
#' @param file The file to be read
#'
#' @return The object saved as file
#'
#' @examples
#' data <- readRDSMC("~/obj.rds")

#' @export
readRDSMC <- function(file) {
  #con <- pipe(paste0("xz -d -k -c ", file))
  con <- pipe(paste0("pigz -d -k -c ", file))
  #  *** caught segfault ***
  # address 0x0, cause 'unknown'
  #
  # Traceback:
  #  1: readRDS(file = con)
  #  2: readRDSMC(getCacheFilenameData(plate))
  #  3: MatData(plate)
  #  4: PlateData(current.plate, select, drop)
  #  5: FUN(X[[i]], ...)
  #  6: lapply(plates, processSingleCellDataPlate, select.features,
  #            drop.features, select.images)
  #  7: getSingleCellData(plates, features)
  object <- tryCatch({
    readRDS(file = con)
  },
  error = function(err) {
    stop("could not read file\n", file, ":\n", err)
  },
  finally = {
    if(exists("con")) close(con)
  })
  return(object)
}